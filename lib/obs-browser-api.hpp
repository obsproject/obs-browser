// SPDX-FileCopyrightText: 2023 tytan652 <tytan652@tytanium.xyz>
//
// SPDX-License-Identifier: GPL-2.0-or-later

#ifndef _OBS_BROWSER_API_H
#define _OBS_BROWSER_API_H

#include <obs.hpp>
#include <util/util.hpp>

#include <QWidget>

#define OBS_BROWSER_API_VERSION 1

/* ==================== INTERNAL DEFINITIONS ==================== */

inline proc_handler_t *_ph;

/* ==================== INTERNAL API FUNCTIONS ==================== */

static inline proc_handler_t *obs_browser_get_ph(void)
{
	proc_handler_t *global_ph = obs_get_proc_handler();
	assert(global_ph != nullptr);

	calldata_t cd = {0};
	if (!proc_handler_call(global_ph, "obs_browser_api_get_ph", &cd))
		blog(LOG_DEBUG,
		     "Unable to fetch obs-browser proc handler object. obs-browser not available?");
	auto ph = static_cast<proc_handler_t *>(calldata_ptr(&cd, "ph"));
	calldata_free(&cd);

	return ph;
}

static inline bool obs_browser_ensure_ph(void)
{
	if (!_ph)
		_ph = obs_browser_get_ph();
	return _ph != nullptr;
}

/* ==================== GENERAL API FUNCTIONS ==================== */

/* Return the compiled obs-browser-api version.
 *
 * It is highly recommended to disable the use the of API if the returned version is not supported
 */
static inline long long obs_browser_get_api_version()
{
	long long version = 0;

	if (!obs_browser_ensure_ph())
		return version;

	calldata_t cd = {0};
	proc_handler_call(_ph, "get_api_version", &cd);
	calldata_get_int(&cd, "version", &version);
	calldata_free(&cd);

	return version;
}

/* Return the compiled QCef version.
 *
 * It is highly recommended to disable the use of the API if the returned version is not supported
 */
static inline long long obs_browser_get_gcef_version()
{
	long long version = 0;

	if (!obs_browser_ensure_ph())
		return version;

	calldata_t cd = {0};
	proc_handler_call(_ph, "get_qcef_version", &cd);
	calldata_get_int(&cd, "version", &version);
	calldata_free(&cd);

	return version;
}

/* ==================== GENERAL API CLASSES ==================== */

/* Wrapped QCefWidget generated through obs-browser-api procedure handler.
 *
 * The widget is wrapped to avoid making QCefWidget definition a public API.
 *
 * OBSBrowserQCefWidget are generated by OBSBrowserQCef::createWidget method
 */
class OBSBrowserQCefWidget : public QObject {
	Q_OBJECT

	friend class OBSBrowserQCef;

	proc_handler_t *ph;
	QWidget *qcef_widget;

private Q_SLOTS:
	void _titleChanged(const QString &title) { emit titleChanged(title); }

	void _urlChanged(const QString &title) { emit urlChanged(title); }

private:
	explicit OBSBrowserQCefWidget(proc_handler_t *ph, QWidget *qcef_widget,
				      QObject *parent = nullptr)
		: QObject(parent), ph(ph), qcef_widget(qcef_widget)
	{
		connect(qcef_widget, SIGNAL(titleChanged(const QString &)),
			this, SLOT(_titleChanged(const QString &)),
			Qt::DirectConnection);
		connect(qcef_widget, SIGNAL(urlChanged(const QString &)), this,
			SLOT(_urlChanged(const QString &)),
			Qt::DirectConnection);

		connect(qcef_widget, &QObject::destroyed, this, [=]() {
			this->qcef_widget = nullptr;
			this->deleteLater();
		});
	}

public:
	~OBSBrowserQCefWidget()
	{
		if (qcef_widget)
			delete qcef_widget;

		proc_handler_destroy(ph);
	}

	/* Return the QCefWidget pointer as a QWidget.
	 *
	 * This is to avoid making QCefWidget definition a public API
	 */
	QWidget *qwidget() { return qcef_widget; }

	void setParent(QWidget *parent)
	{
		QObject::setParent(parent);
		qcef_widget->setParent(parent);
	}

	/* Set the URL used in the widget */
	void setUrl(const char *url)
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_widget", qcef_widget);
		calldata_set_string(&cd, "url", url);
		proc_handler_call(ph, "set_url", &cd);
		calldata_free(&cd);
	}

	/* Set a javascript script to be ran at the widget's browser client startup */
	void setStartupScript(const char *script)
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_widget", qcef_widget);
		calldata_set_string(&cd, "script", script);
		proc_handler_call(ph, "set_startup_script", &cd);
		calldata_free(&cd);
	}

	/* Allow all popups in the widget */
	void allowAllPopups(bool allow)
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_widget", qcef_widget);
		calldata_set_bool(&cd, "allow", allow);
		proc_handler_call(ph, "allow_all_popups", &cd);
		calldata_free(&cd);
	}

	/* Mainly meant to be used in closeEvent (or hideEvent) function.
	 *
	 * This close the widget's browser client allowing to free resources when the widget is actually.
	 *
	 * QCefWidget::showEvent recreate the client when the widget is re-shown
	 */
	void closeBrowser()
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_widget", qcef_widget);
		proc_handler_call(ph, "close_browser", &cd);
		calldata_free(&cd);
	}

	/* Reload the page */
	void reloadPage()
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_widget", qcef_widget);
		proc_handler_call(ph, "reload_page", &cd);
		calldata_free(&cd);
	}

	/* Execute javascript in the widget's browser client */
	void executeJavaScript(const char *script)
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_widget", qcef_widget);
		calldata_set_string(&cd, "script", script);
		proc_handler_call(ph, "execute_javascript", &cd);
		calldata_free(&cd);
	}

Q_SIGNALS:
	/* Wrapper of the original QCefWidget::titleChanged signal.
	 *
	 * This allow to connect this signal using its functor
	 */
	void titleChanged(const QString &title);

	/* Wrapper of the original QCefWidget::urlChanged signal.
	 *
	 * This allow to connect this signal using its functor
	 */
	void urlChanged(const QString &url);
};

/* Wrapped QCefCookieManager generated through obs-browser-api procedure handler.
 *
 * The object is wrapped to avoid making QCefCookieManager a public API.
 *
 * OBSBrowserQCefCookieManager are generated by OBSBrowserQCef::createCookieManager method
 */
class OBSBrowserQCefCookieManager {
	friend class OBSBrowserQCef;

	proc_handler_t *ph;
	void *qcef_cookie_manager;

	OBSBrowserQCefCookieManager(proc_handler_t *ph,
				    void *qcef_cookie_manager)
		: ph(ph), qcef_cookie_manager(qcef_cookie_manager)
	{
	}

public:
	~OBSBrowserQCefCookieManager()
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_cookie_manager",
				 qcef_cookie_manager);
		proc_handler_call(ph, "qcef_cookie_manager_free", &cd);
		calldata_free(&cd);

		proc_handler_destroy(ph);
	};

	/* Delete cookies matching the given url and/or the given name.
	 *
	 * Empty string (or nullptr) are wildcards for both parameters
	 */
	bool deleteCookies(const char *url, const char *name)
	{
		bool success = false;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_cookie_manager",
				 qcef_cookie_manager);
		calldata_set_string(&cd, "url", url);
		calldata_set_string(&cd, "name", name);
		proc_handler_call(ph, "delete_cookies", &cd);
		calldata_get_bool(&cd, "success", &success);
		calldata_free(&cd);

		return success;
	}

	/* Flush the backing store (if any) to disk */
	bool flushStore()
	{
		bool success = false;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_cookie_manager",
				 qcef_cookie_manager);
		proc_handler_call(ph, "flush_store", &cd);
		calldata_get_bool(&cd, "success", &success);
		calldata_free(&cd);

		return success;
	}

	typedef std::function<void(bool)> cookie_exists_cb;

	/* Check for a cookie with matching parameter with a callback.
	 *
	 * Note, the bool parameter of the callback is set to true if the cookie is found
	 */
	void checkForCookie(const char *url, const char *cookie,
			    cookie_exists_cb callback)
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef_cookie_manager",
				 qcef_cookie_manager);
		calldata_set_string(&cd, "url", url);
		calldata_set_string(&cd, "cookie", cookie);
		calldata_set_ptr(&cd, "callback", &callback);
		proc_handler_call(ph, "check_for_cookie", &cd);
		calldata_free(&cd);
	}
};

/* Wrapped QCef generated through obs-browser-api procedure handler.
 *
 * The object is wrapped to avoid making QCef a public API.
 *
 * OBSBrowserQCef are generated by OBSBrowserQCef::createOBSBrowserQCef method
 */
class OBSBrowserQCef {
	proc_handler_t *ph;
	void *qcef;

	OBSBrowserQCef(proc_handler_t *ph, void *qcef) : ph(ph), qcef(qcef){};

public:
	/* Creates and return a OBSBrowserQCef instance.
	 *
	 * Can return an empty shared pointer
	 */
	static std::shared_ptr<OBSBrowserQCef> createOBSBrowserQCef()
	{
		bool ret = false;
		proc_handler_t *ph = nullptr;
		void *qcef = nullptr;

		if (!obs_browser_ensure_ph())
			return {};

		calldata_t cd = {0};
		ret = proc_handler_call(_ph, "create_qcef", &cd);
		calldata_get_ptr(&cd, "ph", &ph);
		calldata_get_ptr(&cd, "qcef", &qcef);
		calldata_free(&cd);

		if (!ret)
			return {};

		return std::shared_ptr<OBSBrowserQCef>(
			new OBSBrowserQCef(ph, qcef));
	}

	~OBSBrowserQCef()
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		proc_handler_call(ph, "qcef_free", &cd);
		calldata_free(&cd);

		proc_handler_destroy(ph);
	};

	/* Initialize the browser if not already initialized.
	 *
	 * Return true if already initialized
	 */
	bool initBrowser()
	{
		bool already_initialized = false;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		proc_handler_call(ph, "init_browser", &cd);
		calldata_get_bool(&cd, "already_initialized",
				  &already_initialized);
		calldata_free(&cd);

		return already_initialized;
	}

	/* Return if the browser is initialized */
	bool initialized()
	{
		bool initialized = false;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		proc_handler_call(ph, "initialized", &cd);
		calldata_get_bool(&cd, "initialized", &initialized);
		calldata_free(&cd);

		return initialized;
	}

	/* Return when the browser is initialized */
	bool waitForBrowserInit()
	{
		bool initialized = false;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		proc_handler_call(ph, "wait_for_browser_init", &cd);
		calldata_get_bool(&cd, "initialized", &initialized);
		calldata_free(&cd);

		return initialized;
	}

	/* Creates and return a OBSBrowserQCefWidget instance.
	 *
	 * Can return nullptr
	 */
	OBSBrowserQCefWidget *
	createWidget(QWidget *parent, const char *url,
		     OBSBrowserQCefCookieManager *cookie_manager = nullptr)
	{
		bool ret = false;
		proc_handler_t *w_ph = nullptr;
		QWidget *qcef_widget = nullptr;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		calldata_set_ptr(&cd, "qwidget_parent", parent);
		calldata_set_string(&cd, "url", url);
		calldata_set_ptr(&cd, "qcef_cookie_manager", cookie_manager);
		ret = proc_handler_call(ph, "create_widget", &cd);
		calldata_get_ptr(&cd, "ph", &w_ph);
		qcef_widget = static_cast<QWidget *>(
			calldata_ptr(&cd, "qcef_widget"));
		calldata_free(&cd);

		return ret ? new OBSBrowserQCefWidget(w_ph, qcef_widget, parent)
			   : nullptr;
	}

	/* Creates and return a OBSBrowserQCefCookieManager instance.
	 *
	 * Can return an empty shared pointer
	 */
	std::shared_ptr<OBSBrowserQCefCookieManager>
	createCookieManager(const char *storage_path,
			    bool persist_session_cookies = false)
	{
		bool ret = false;
		proc_handler_t *cm_ph = nullptr;
		void *cookie_manager = nullptr;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		calldata_set_string(&cd, "storage_path", storage_path);
		calldata_set_bool(&cd, "persist_session_cookies",
				  persist_session_cookies);
		ret = proc_handler_call(ph, "create_cookie_manager", &cd);
		calldata_get_ptr(&cd, "ph", &cm_ph);
		calldata_get_ptr(&cd, "qcef_cookie_manager", &cookie_manager);
		calldata_free(&cd);

		if (!ret)
			return {};

		return std::shared_ptr<OBSBrowserQCefCookieManager>(
			new OBSBrowserQCefCookieManager(cm_ph, cookie_manager));
	}

	/* Return the cookie path */
	BPtr<char> getCookiePath(const char *storage_path)
	{
		char *cookie_path = nullptr;

		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		calldata_set_string(&cd, "storage_path", storage_path);
		proc_handler_call(ph, "get_cookie_path", &cd);
		cookie_path = static_cast<char *>(calldata_ptr(&cd, "path"));
		calldata_free(&cd);

		return cookie_path;
	}

	/* Add an URL to the popup whitelist.
	 *
	 * The list is global to all QCef instances.
	 *
	 * The URL is kept until the given QObject is checked and found destroyed
	 */
	void addPopupWhitelistUrl(const char *url, QObject *obj)
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		calldata_set_string(&cd, "url", url);
		calldata_set_ptr(&cd, "qobject", obj);
		proc_handler_call(ph, "add_popup_whitelist_url", &cd);
		calldata_free(&cd);
	}

	/* Force the given URL to be a popup
	 *
	 * The list is global to all QCef instances.
	 *
	 * The URL is kept until the given QObject is checked and found destroyed
	 */
	void addForcePopupUrl(const char *url, QObject *obj)
	{
		calldata_t cd = {0};
		calldata_init(&cd);
		calldata_set_ptr(&cd, "qcef", qcef);
		calldata_set_string(&cd, "url", url);
		calldata_set_ptr(&cd, "qobject", obj);
		proc_handler_call(ph, "add_force_popup_url", &cd);
		calldata_free(&cd);
	}
};

#endif //_OBS_BROWSER_API_H
